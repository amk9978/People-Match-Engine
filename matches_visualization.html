<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Match Graph (Chosen Subgraph)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    :root { --bg:#f5f5f5; --card:#fff; --text:#333; --muted:#666; --shadow:0 2px 6px rgba(0,0,0,.08); }
    *{box-sizing:border-box}
    body{margin:0;padding:24px;font-family:system-ui,Segoe UI,Roboto,Ubuntu,Arial;background:var(--bg);color:var(--text)}
    .container{max-width:1200px;margin:0 auto}
    h1{margin:0 0 16px;text-align:center;font-weight:600}
    .bar{display:flex;flex-wrap:wrap;align-items:center;gap:12px 20px;background:var(--card);padding:14px 16px;border-radius:10px;box-shadow:var(--shadow);margin-bottom:16px}
    .bar label{font-weight:600;margin-right:6px}
    .bar input[type="range"]{width:200px}
    .bar .sp{min-width:44px;display:inline-block;text-align:right}
    .bar .grow{flex:1 1 auto}
    .btn{padding:8px 10px;border:0;border-radius:8px;background:#2d6cdf;color:#fff;cursor:pointer}
    .btn.secondary{background:#818cf8}
    .sep{width:1px;height:26px;background:#e6e6e6;margin:0 4px}
    .hint{color:var(--muted);font-size:12px}
    #status{color:var(--muted);padding:10px 0;font-size:14px;text-align:center}
    #graph-card{position:relative;background:var(--card);border-radius:12px;box-shadow:var(--shadow);overflow:hidden}
    #graph{width:100%;height:800px;display:block}
    .legend{position:absolute;right:16px;top:16px;background:rgba(255,255,255,.94);padding:10px 12px;border-radius:8px;box-shadow:var(--shadow);font-size:12px}
    .legend-item{display:flex;align-items:center;gap:8px;margin:6px 0}
    .legend-dot{width:12px;height:12px;border-radius:50%}
    .tooltip{position:absolute;pointer-events:none;background:rgba(0,0,0,.82);color:#fff;padding:8px 10px;border-radius:6px;font-size:12px;z-index:1000;transform:translate(-50%,-120%);white-space:nowrap}
    /* List */
    #list-card{margin-top:16px;background:var(--card);border-radius:12px;box-shadow:var(--shadow);overflow:hidden}
    .list-bar{display:flex;align-items:center;gap:10px;padding:12px 14px;border-bottom:1px solid #eee}
    .list-bar input{flex:1 1 auto;padding:8px 10px;border:1px solid #ddd;border-radius:8px}
    .count{color:var(--muted);font-size:12px}
    table{width:100%;border-collapse:collapse;font-size:14px}
    thead{background:#fafafa}
    th,td{padding:10px 12px;border-bottom:1px solid #eee;text-align:left}
    tbody tr:hover{background:#fcfcfc}
  </style>
</head>
<body>
  <div class="container">
    <h1>Match Graph</h1>

    <div class="bar">
      <div>
        <label for="file">Load JSON:</label>
        <input type="file" id="file" accept=".json" />
        <span class="hint">or place <code>res1.json</code> next to this file.</span>
      </div>
      <div class="sep"></div>
      <div>
        <label for="threshold">Score ≥</label>
        <!-- static range 0..1 (cosine), no dynamic scaling -->
        <input type="range" id="threshold" min="0" max="1" step="0.005" value="0.04" />
        <span class="sp" id="thval">0.040</span>
      </div>
      <div>
        <label for="layout">Layout</label>
        <select id="layout">
          <option value="force">Force</option>
          <option value="radial">Radial</option>
        </select>
      </div>
      <div class="grow"></div>
      <button class="btn" id="reset-pos">Reset Position</button>
      <button class="btn secondary" id="reset-zoom">Reset Zoom</button>
    </div>

    <div id="status">Loading <code>res1.json</code>…</div>

    <div id="graph-card">
      <svg id="graph" viewBox="0 0 100 100" preserveAspectRatio="xMidYMid meet"></svg>
      <div class="legend">
        <div class="legend-item"><span class="legend-dot" style="background:#e53e3e"></span> Strong (Top 25%)</div>
        <div class="legend-item"><span class="legend-dot" style="background:#38b2ac"></span> Medium (Top 50%)</div>
        <div class="legend-item"><span class="legend-dot" style="background:#a0aec0"></span> Weak (Bottom 50%)</div>
      </div>
    </div>

    <!-- People list (only nodes currently visible in the chosen subgraph) -->
    <div id="list-card">
      <div class="list-bar">
        <strong>People (visible)</strong>
        <span class="count" id="list-count"></span>
        <input id="list-search" placeholder="Search name or ID…" />
      </div>
      <table>
        <thead><tr><th>Name</th><th>Weighted Degree</th><th>ID</th></tr></thead>
        <tbody id="people-body"></tbody>
      </table>
    </div>
  </div>

  <script>
    let graphData = null, width = 800, height = 800, svg, rootG, simulation, zoomBehavior, currentTransform = d3.zoomIdentity;
    let currentNodes = [], currentDegree = new Map(); // for list filtering
    const $ = sel => document.querySelector(sel);

    function getContainerWidth(){
      const rc = $('#graph-card').getBoundingClientRect();
      return rc.width > 0 ? rc.width : Math.max(320, window.innerWidth - 40);
    }
    function getLinkedInName(id){
      if (!id) return 'Unknown';
      const m = String(id).match(/linkedin\.com\/in\/([^/?#]+)/i);
      return m ? m[1].replace(/-/g, ' ') : String(id).slice(-32);
    }

    // Use chosen subgraph if present; fallback to matches
    function processDataForGraph(data){
      const usingDense = Array.isArray(data.dense_subgraph);
      const base = usingDense ? data.dense_subgraph : (data.matches || []);
      const allowed = usingDense ? new Set(base.map(p => p.id)) : null;

      const nodes = new Map(), links = [];
      base.forEach(p => {
        if (!nodes.has(p.id)) nodes.set(p.id, { id: p.id, name: getLinkedInName(p.id) });
        (p.neighbors || []).forEach(n => {
          if (usingDense && !allowed.has(n.id)) return; // drop edges to outside nodes
          if (!nodes.has(n.id)) nodes.set(n.id, { id: n.id, name: getLinkedInName(n.id) });
          links.push({ source: p.id, target: n.id, score: +n.score || 0, weight: (+n.score || 0) * 10 });
        });
      });
      return { nodes: Array.from(nodes.values()), links, usingDense };
    }

    function linkColor(s){ return s > 0.08 ? '#ff6b6b' : (s > 0.04 ? '#4ecdc4' : '#95a5a6'); }
    function nodeColor(d){ return d > 15 ? '#e74c3c' : (d > 8 ? '#f39c12' : (d > 3 ? '#3498db' : '#95a5a6')); }

    function initSvg(){
      width = getContainerWidth(); height = 800;
      svg = d3.select('#graph')
        .attr('width', width).attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet');
      svg.selectAll('*').remove();
      rootG = svg.append('g').attr('id', 'root');
      zoomBehavior = d3.zoom().scaleExtent([0.1, 6]).on('zoom', ev => { currentTransform = ev.transform; rootG.attr('transform', currentTransform); });
      svg.call(zoomBehavior).call(zoomBehavior.transform, currentTransform);
      if (!document.querySelector('.tooltip')) d3.select('body').append('div').attr('class', 'tooltip').style('opacity', 0);
    }

    function renderList(nodes, degree){
      const q = $('#list-search').value.trim().toLowerCase();
      const tbody = $('#people-body');
      const rows = nodes
        .filter(n => !q || n.name.toLowerCase().includes(q) || String(n.id).toLowerCase().includes(q))
        .sort((a,b) => (degree.get(b.id)||0)-(degree.get(a.id)||0) || a.name.localeCompare(b.name));
      $('#list-count').textContent = `${rows.length}/${nodes.length} shown`;
      tbody.innerHTML = rows.map(n => {
        const deg = degree.get(n.id) || 0;
        const isUrl = /^https?:\/\//i.test(n.id);
        const idCell = isUrl ? `<a href="${n.id}" target="_blank" rel="noopener">${n.id}</a>` : n.id;
        return `<tr><td>${escapeHtml(n.name)}</td><td>${deg.toFixed(3)}</td><td style="max-width:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap">${idCell}</td></tr>`;
      }).join('');
    }
    function escapeHtml(s){return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]))}

    function updateGraph(){
      if (!graphData) return;
      if (simulation){ simulation.stop(); simulation = null; }

      const threshold = +$('#threshold').value; $('#thval').textContent = threshold.toFixed(3);
      const layout = $('#layout').value;

      // Filter links and keep only connected nodes
      const links = graphData.links.filter(l => l.score >= threshold);
      const connected = new Set(); links.forEach(l => { connected.add(l.source); connected.add(l.target); });
      const nodes = graphData.nodes.filter(n => connected.has(n.id));

      // Build weight-aware scales (1. Normalize edge weights once and use d3 scales for all visuals)
      const wExtent = d3.extent(links, d => d.score);
      const wLo = Math.max(0.0001, wExtent[0] ?? 0.0001);
      const wHi = Math.max(wLo + 1e-6, wExtent[1] ?? 1.0);

      // Normalized weight in [0,1] for consistent controls
      const wNorm = d3.scaleLinear().domain([wLo, wHi]).range([0, 1]);

      // Visual mappings - more dramatic scaling for better distinction
      const linkDistance = d3.scaleLinear().domain([wLo, wHi]).range([200, 15]);   // strong => much shorter
      const linkStrength = d3.scaleLinear().domain([wLo, wHi]).range([0.05, 1.5]); // stronger range
      const linkWidth    = d3.scalePow().exponent(0.7).domain([wLo, wHi]).range([0.8, 20]); // much wider range
      const linkOpacity  = d3.scaleLinear().domain([wLo, wHi]).range([0.3, 0.95]);  // opacity variation
      const nodeRadius   = d3.scaleSqrt().range([6, 18]);                           // set domain below

      // Weighted degree ("node strength") (2. Compute weighted degree for node sizing)
      const wdeg = new Map();
      nodes.forEach(n => wdeg.set(n.id, 0));
      links.forEach(l => {
        wdeg.set(l.source, (wdeg.get(l.source) || 0) + l.score);
        wdeg.set(l.target, (wdeg.get(l.target) || 0) + l.score);
      });
      const wdegExtent = d3.extent(nodes, n => wdeg.get(n.id) || 0);
      nodeRadius.domain([Math.max(0, wdegExtent[0] || 0), Math.max(1e-6, wdegExtent[1] || 1)]);

      // Degree in the filtered graph (keep for backward compatibility)
      const degree = new Map(); nodes.forEach(n => degree.set(n.id, 0));
      links.forEach(l => { degree.set(l.source, (degree.get(l.source)||0)+1); degree.set(l.target, (degree.get(l.target)||0)+1); });

      // Persist for list search (use weighted degree for better representation)
      currentNodes = nodes;
      currentDegree = wdeg; // Use weighted degree instead of raw degree
      renderList(currentNodes, currentDegree);

      rootG.selectAll('*').remove();
      if (nodes.length === 0){
        rootG.append('text').attr('x', width/2).attr('y', height/2)
          .attr('text-anchor','middle').attr('fill','#777').style('font-size','16px')
          .text('No connections above threshold');
        return;
      }

      // 3. Use the scales in your marks and forces - enhanced visual distinction
      // Links with dynamic color thresholds based on actual data
      const scoreThresholds = {
        high: wLo + (wHi - wLo) * 0.75,  // top 25%
        med:  wLo + (wHi - wLo) * 0.5    // top 50%
      };
      
      const link = rootG.append('g')
        .attr('stroke-linecap','round')
        .selectAll('line').data(links).join('line')
        .attr('stroke', d => d.score >= scoreThresholds.high ? '#e53e3e' : 
                           (d.score >= scoreThresholds.med ? '#38b2ac' : '#a0aec0'))
        .attr('stroke-opacity', d => linkOpacity(d.score))
        .attr('stroke-width', d => linkWidth(d.score))
        .style('cursor', 'pointer')
        .on('mouseover', function(ev, d) {
          d3.select(this)
            .attr('stroke-width', linkWidth(d.score) * 1.5)
            .attr('stroke-opacity', Math.min(1, linkOpacity(d.score) + 0.3));
          
          const tooltip = d3.select('.tooltip');
          const sourceNode = nodes.find(n => n.id === d.source.id || n.id === d.source);
          const targetNode = nodes.find(n => n.id === d.target.id || n.id === d.target);
          
          tooltip.style('opacity', 1)
            .html(`<strong>Connection</strong><br/>${sourceNode?.name || 'Unknown'} ↔ ${targetNode?.name || 'Unknown'}<br/>Weight: ${d.score.toFixed(4)}`)
            .style('left', ev.pageX + 'px')
            .style('top', (ev.pageY - 10) + 'px');
        })
        .on('mouseout', function(ev, d) {
          d3.select(this)
            .attr('stroke-width', linkWidth(d.score))
            .attr('stroke-opacity', linkOpacity(d.score));
          d3.select('.tooltip').style('opacity', 0);
        });

      // Nodes
      const node = rootG.append('g').selectAll('circle').data(nodes, d => d.id).join('circle')
        .attr('r', d => nodeRadius(wdeg.get(d.id) || 0))
        .attr('fill', d => {
          const s = wdeg.get(d.id) || 0;
          return s > (wdegExtent[1]*0.66) ? '#e74c3c' : s > (wdegExtent[1]*0.33) ? '#f39c12' : '#3498db';
        })
        .attr('stroke','#333').attr('stroke-width',1.2)
        .call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended));

      const label = rootG.append('g').selectAll('text').data(nodes, d => d.id).join('text')
        .attr('text-anchor','middle').attr('font-size',10).attr('fill','#333')
        .text(d => d.name.length > 18 ? d.name.slice(0,15) + '…' : d.name);

      // 4. Make the tooltip show the actual weight
      const tooltip = d3.select('.tooltip');
      node.on('mouseover', (ev, d) => {
        const deg = wdeg.get(d.id) || 0;
        tooltip.style('opacity', 1)
          .html(`<strong>${escapeHtml(d.name)}</strong><br/>Weighted degree: ${deg.toFixed(3)}<br/>${/^https?:\/\//i.test(d.id) ? `<a href="${d.id}" target="_blank">LinkedIn</a>` : 'No LinkedIn'}`)
          .style('left', ev.pageX + 'px')
          .style('top', (ev.pageY - 10) + 'px');
      }).on('mouseout', () => tooltip.style('opacity', 0));

      if (layout === 'force'){
        // Force sim — strength & distance both depend on weight
        simulation = d3.forceSimulation(nodes)
          .force('link', d3.forceLink(links)
              .id(d => d.id)
              .distance(d => linkDistance(d.score))
              .strength(d => linkStrength(d.score)))
          .force('charge', d3.forceManyBody().strength(-28 * Math.sqrt(nodes.length))) // scale with n
          .force('center', d3.forceCenter(width/2, height/2))
          .force('x', d3.forceX(width/2).strength(0.06))
          .force('y', d3.forceY(height/2).strength(0.06))
          .force('collide', d3.forceCollide().radius(d => nodeRadius(wdeg.get(d.id)||0) + 4).iterations(2))
          .on('tick', () => {
              link.attr('x1', d => d.source.x).attr('y1', d => d.source.y)
                  .attr('x2', d => d.target.x).attr('y2', d => d.target.y);
              node.attr('cx', d => clamp(d.x, 10, width-10))
                  .attr('cy', d => clamp(d.y, 10, height-10));
              label.attr('x', d => clamp(d.x, 10, width-10))
                   .attr('y', d => clamp(d.y, 10, height-10) + 12);
          });
      } else {
        const R = Math.min(width, height) * 0.35;
        nodes.forEach((n, i) => {
          const a = (i / nodes.length) * 2 * Math.PI;
          n.x = width/2 + R * Math.cos(a);
          n.y = height/2 + R * Math.sin(a);
        });
        const posX = d => d.x, posY = d => d.y;
        link.attr('x1', d => posX(d.source)).attr('y1', d => posY(d.source)).attr('x2', d => posX(d.target)).attr('y2', d => posY(d.target));
        node.attr('cx', posX).attr('cy', posY);
        label.attr('x', posX).attr('y', d => posY(d) + 12);
      }
    }

    function clamp(v, min, max){ return Math.max(min, Math.min(max, v)); }
    function dragstarted(ev, d){ if (simulation && !ev.active) simulation.alphaTarget(0.3).restart(); d.fx = d.x; d.fy = d.y; }
    function dragged(ev, d){ d.fx = ev.x; d.fy = ev.y; }
    function dragended(ev, d){ if (simulation && !ev.active) simulation.alphaTarget(0); d.fx = null; d.fy = null; }

    // Events
    window.addEventListener('resize', () => { initSvg(); updateGraph(); });
    $('#threshold').addEventListener('input', updateGraph);
    $('#layout').addEventListener('change', updateGraph);
    $('#reset-pos').addEventListener('click', () => { if (simulation) simulation.alpha(1).restart(); });
    $('#reset-zoom').addEventListener('click', () => { currentTransform = d3.zoomIdentity; svg.transition().duration(300).call(zoomBehavior.transform, currentTransform); });
    $('#list-search').addEventListener('input', () => renderList(currentNodes, currentDegree));

    // File picker
    $('#file').addEventListener('change', async e => {
      const f = e.target.files && e.target.files[0]; if (!f) return;
      try {
        const txt = await f.text();
        const data = JSON.parse(txt);
        graphData = processDataForGraph(data);
        $('#status').textContent = (Array.isArray(data.dense_subgraph) ? 'Showing chosen subgraph: ' : 'Showing full matches: ')
          + `${graphData.nodes.length} nodes / ${graphData.links.length} links.`;
        initializeThreshold();
        initSvg(); updateGraph();
      } catch (err) {
        console.error(err);
        $('#status').textContent = 'Failed to parse JSON file.';
      }
    });

    // 5. Threshold slider: filter by weight, not arbitrary units
    function initializeThreshold() {
      if (!graphData || !graphData.links.length) return;
      
      // After computing links:
      const weightsSorted = [...graphData.links.map(l => l.score)].sort((a,b)=>a-b);
      const q = weightsSorted[Math.floor(0.8 * (weightsSorted.length-1))] || 0.04; // 80th percentile
      document.getElementById('threshold').value = q.toFixed(3);
      document.getElementById('thval').textContent = (+q).toFixed(3);
    }

    // Try loading res1.json on page load (optional)
    (async function bootstrap(){
      initSvg();
      try{
        const r = await fetch('res1.json', { cache: 'no-store' });
        if (!r.ok) throw new Error('HTTP ' + r.status);
        const data = await r.json();
        graphData = processDataForGraph(data);
        $('#status').textContent = (Array.isArray(data.dense_subgraph) ? 'Showing chosen subgraph: ' : 'Showing full matches: ')
          + `${graphData.nodes.length} nodes / ${graphData.links.length} links.`;
        initializeThreshold();
        updateGraph();
      }catch{
        $('#status').textContent = 'Pick a JSON file with the file picker (expected /analyze response).';
      }
    })();
  </script>
</body>
</html>
